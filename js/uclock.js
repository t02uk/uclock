// Generated by CoffeeScript 1.6.3
(function() {
  var CameraController, Effecter, God, LetterAggregater, LetterBase, LetterMin, LetterSec, Util, __DEBUG__,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  __DEBUG__ = false;

  Util = (function() {
    function Util() {}

    Util.pad = function(str, padWith, len) {
      var refrain;
      refrain = function(str, len) {
        return Array(len + 1).join(str);
      };
      return (refrain(padWith, len) + str).slice(-len);
    };

    Util.zeroPad = function(str, len) {
      return Util.pad(str, "0", len);
    };

    return Util;

  })();

  God = (function() {
    function God() {}

    God.setup = function() {
      var i;
      this.deviceWidth = 640.0;
      this.deviceHeight = 480.0;
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(90, this.deviceWidth / this.deviceHeight, Math.pow(0.1, 8), Math.pow(10, 3));
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.deviceWidth, this.deviceHeight);
      this.renderer.setClearColor(0xffffff, 0);
      this.cm = new CameraController(this.camera);
      this.letterSecs = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 59; i = ++_i) {
          _results.push(new LetterSec(this.scene, i));
        }
        return _results;
      }).call(this);
      this.letterMin = new LetterMin(this.scene);
      return this.effecter = new Effecter(this.renderer.domElement, document.getElementById('c'));
    };

    God.start = function() {
      var hour, hour_, min, min_, ms, ms_, render, s, s_,
        _this = this;
      hour = min = s = ms = -1;
      hour_ = min_ = s_ = ms_ = -1;
      render = function() {
        var date, letterSec, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
        date = new Date();
        _ref = [date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()], hour = _ref[0], min = _ref[1], s = _ref[2], ms = _ref[3];
        if (s !== s_) {
          _this.cm.lookLetter(_this.letterSecs[s]);
        }
        _this.cm.update();
        if (min !== min_ && s === 0) {
          _ref1 = _this.letterSecs;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            letterSec = _ref1[_i];
            letterSec.z = 100;
          }
        }
        _ref2 = _this.letterSecs;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          letterSec = _ref2[_j];
          letterSec.update(ms);
        }
        _this.letterMin.update(Util.zeroPad(hour, 2) + ":" + Util.zeroPad(min, 2));
        requestAnimationFrame(render);
        _this.renderer.render(_this.scene, _this.camera);
        _this.effecter.update(_this.cm.movingLength);
        return _ref3 = [hour, min, s, ms], hour_ = _ref3[0], min_ = _ref3[1], s_ = _ref3[2], ms_ = _ref3[3], _ref3;
      };
      return render();
    };

    return God;

  })();

  CameraController = (function() {
    function CameraController(camera) {
      this.camera = camera;
      this.lookAt = new THREE.Vector3(0, 0, 0);
    }

    CameraController.prototype.lookLetter = function(lookedLetter) {
      return this.lookedLetter = lookedLetter;
    };

    CameraController.prototype.update = function() {
      var lp, _pos;
      lp = this.lookedLetter.position();
      _pos = this.camera.position.clone();
      this.camera.position.x = (this.camera.position.x * 19 + lp.x * 1.5) / 20;
      this.camera.position.y = (this.camera.position.y * 19 + lp.y * 1.5) / 20;
      this.camera.position.z = (this.camera.position.z * 19 + lp.z * 1.5) / 20;
      this.lookAt.x = (this.lookAt.x * 4 + lp.x) / 5;
      this.lookAt.y = (this.lookAt.y * 4 + lp.y) / 5;
      this.lookAt.z = (this.lookAt.z * 4 + lp.z) / 5;
      this.camera.lookAt(this.lookAt);
      return this.movingLength = _pos.distanceTo(this.camera.position);
    };

    return CameraController;

  })();

  LetterAggregater = (function() {
    function LetterAggregater() {}

    LetterAggregater.letters = [];

    LetterAggregater.append = function(LetterSec) {
      return LetterAggregater.letters.push(LetterSec);
    };

    return LetterAggregater;

  })();

  LetterBase = (function() {
    LetterBase.textureMemo = {};

    function LetterBase(scene, number, size, digits, color) {
      this.scene = scene;
      this.number = number;
      this.size = size;
      this.digits = digits;
      this.color = color;
      this.material = this.retrieveMaterial(this.number, this.digits, this.color);
      this.geometry = new THREE.PlaneGeometry(this.size, this.size);
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.scene.add(this.mesh);
    }

    LetterBase.prototype.position = function() {
      return this.mesh.position;
    };

    LetterBase.prototype.rotation = function() {
      return this.mesh.rotation;
    };

    LetterBase.prototype.retrieveMaterial = function(number, digits, color) {
      return this.material = new THREE.MeshBasicMaterial({
        map: this.makeTexture(number, digits),
        transparent: true,
        color: color,
        depthTest: false,
        side: THREE.DoubleSide
      });
    };

    LetterBase.prototype.makeTexture = function(number, digits) {
      var ctx, height, key, width;
      key = "" + number;
      if (!LetterBase.textureMemo[key]) {
        this.canvas = document.createElement('canvas');
        width = this.canvas.width = 64 * digits;
        height = this.canvas.height = 128;
        ctx = this.canvas.getContext('2d');
        ctx.textAlign = 'center';
        ctx.textBaseLine = 'top';
        ctx.font = "" + (height * 3 / 4) + "px sans-serif";
        ctx.fillStyle = "rgb(255, 255, 255)";
        ctx.fillText(number, width / 2, height * 3 / 4);
        this.texture = THREE.ImageUtils.loadTexture(this.canvas.toDataURL());
        LetterBase.textureMemo[key] = this.texture;
        if (__DEBUG__) {
          document.body.appendChild(this.canvas);
        }
      }
      return LetterBase.textureMemo[key];
    };

    return LetterBase;

  })();

  LetterMin = (function(_super) {
    __extends(LetterMin, _super);

    function LetterMin(scene, number) {
      LetterMin.__super__.constructor.call(this, scene, number, 5, 5, 0x999999);
      this.c = 0;
    }

    LetterMin.prototype.update = function(number) {
      if (this.number !== number) {
        this.material.map = this.makeTexture(number, 5);
      }
      this.mesh.rotation.x += Math.sin(this.c * 0.01 + 0.0) * 0.02;
      this.mesh.rotation.y += Math.sin(this.c * 0.02 + 0.5) * 0.02;
      this.mesh.rotation.z += Math.sin(this.c * 0.03 + 1.0) * 0.02;
      this.material.needsUpdate = true;
      this.number = number;
      return this.c++;
    };

    return LetterMin;

  })(LetterBase);

  LetterSec = (function(_super) {
    __extends(LetterSec, _super);

    function LetterSec(scene, number) {
      var last, needForRetry, that, _i, _len, _ref;
      LetterSec.__super__.constructor.call(this, scene, number, 1, 2, ~~(Math.random() * 0x666666) + 0x666666);
      last = LetterAggregater.letters.length > 0 ? LetterAggregater.letters[LetterAggregater.letters.length - 1].mesh.rotation : new THREE.Euler();
      while (true) {
        if (Math.random() > 0.2) {
          this.mesh.rotation.x = last.x + Math.random() * 1.5 - 0.75;
          this.mesh.rotation.y = last.y + Math.random() * 1.5 - 0.75;
          this.mesh.rotation.z = last.z + Math.random() * 1.5 - 0.75;
        } else {
          this.mesh.rotation.x = Math.random() * Math.PI * 2 - Math.PI;
          this.mesh.rotation.y = Math.random() * Math.PI * 2 - Math.PI;
          this.mesh.rotation.z = Math.random() * Math.PI * 2 - Math.PI;
        }
        this.mesh.position.set(0, 0, 5);
        this.mesh.position.applyEuler(this.mesh.rotation);
        needForRetry = false;
        _ref = LetterAggregater.letters;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          that = _ref[_i];
          if (that.position().distanceToSquared(this.position()) < 0.8) {
            needForRetry = true;
            break;
          }
        }
        if (!needForRetry) {
          break;
        }
      }
      LetterAggregater.append(this);
      this.z = 100;
      this.tz = 6;
    }

    LetterSec.prototype.update = function(ms) {
      this.z = (this.tz + this.z * 9) / 10;
      this.mesh.position.set(0, 0, this.z);
      return this.mesh.position.applyEuler(this.mesh.rotation);
    };

    return LetterSec;

  })(LetterBase);

  Effecter = (function() {
    function Effecter(fromCanvas, destCanvas) {
      this.fromCanvas = fromCanvas;
      this.destCanvas = destCanvas;
      this.destCtx = this.destCanvas.getContext('2d');
    }

    Effecter.prototype.update = function(power) {
      var dh, dx, dy, f, i, sh, sy, _i, _results;
      f = power * 3 + 0.25;
      if (f > 0.7) {
        f = 0.7;
      }
      _results = [];
      for (i = _i = 0; _i < 40; i = ++_i) {
        i *= 0.025;
        dy = i * 480 + (Math.random() * 40 - 20) * f * f;
        dx = (Math.random() * 40 - 20) * f * f;
        sy = i * 480;
        sh = dh = i * 480;
        this.destCtx.globalAlpha = 0.05 * f + 0.1;
        this.destCtx.globalCompositeOperation = 'source-over';
        this.destCtx.fillStyle = 'rgb(0, 0, 0)';
        _results.push(this.destCtx.drawImage(this.fromCanvas, 0, sy, 640, sh, dx, dy, 640, dh));
      }
      return _results;
    };

    return Effecter;

  })();

  window.God = God;

}).call(this);

/*
//@ sourceMappingURL=uclock.map
*/
